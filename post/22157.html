<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>GFS: The Google file system | pEacill</title><meta name="author" content="pEacill"><meta name="copyright" content="pEacill"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文将详细介绍由Google在2003年提出的分布式文件系统GFS（Google File System）。GFS是一个分布式的可扩展文件系统，主要用于大规模的数据密集型应用。 论文参考：《The Google File System》 GFS设计&emsp;&emsp;GFS是一个用于支持分布式应用程序的文件系统，在分布式文件系统中，我们需要考虑以下问题：首先，组件的失败是不可避免的，比如磁盘损">
<meta property="og:type" content="article">
<meta property="og:title" content="GFS: The Google file system">
<meta property="og:url" content="https://peacill.online/post/22157.html">
<meta property="og:site_name" content="pEacill">
<meta property="og:description" content="本文将详细介绍由Google在2003年提出的分布式文件系统GFS（Google File System）。GFS是一个分布式的可扩展文件系统，主要用于大规模的数据密集型应用。 论文参考：《The Google File System》 GFS设计&emsp;&emsp;GFS是一个用于支持分布式应用程序的文件系统，在分布式文件系统中，我们需要考虑以下问题：首先，组件的失败是不可避免的，比如磁盘损">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://peacill.online/img/blog/GFS/gfs_cover.jpg">
<meta property="article:published_time" content="2024-12-22T05:20:45.000Z">
<meta property="article:modified_time" content="2024-12-23T07:23:06.024Z">
<meta property="article:author" content="pEacill">
<meta property="article:tag" content="Distributed">
<meta property="article:tag" content="File System">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://peacill.online/img/blog/GFS/gfs_cover.jpg"><link rel="shortcut icon" href="/img/head.jpg"><link rel="canonical" href="https://peacill.online/post/22157.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'GFS: The Google file system',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="pEacill" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Friend</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/blog/GFS/gfs_cover.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">pEacill</span></a><a class="nav-page-title" href="/"><span class="site-name">GFS: The Google file system</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Friend</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">GFS: The Google file system</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-22T05:20:45.000Z" title="发表于 2024-12-22 13:20:45">2024-12-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-23T07:23:06.024Z" title="更新于 2024-12-23 15:23:06">2024-12-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Distributed/">Distributed</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/post/22157.html#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>本文将详细介绍由Google在2003年提出的分布式文件系统GFS（Google File System）。GFS是一个分布式的可扩展文件系统，主要用于大规模的数据密集型应用。</p>
<p>论文参考：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/gfs.pdf">《The Google File System》</a></p>
<h1 id="GFS设计"><a href="#GFS设计" class="headerlink" title="GFS设计"></a>GFS设计</h1><p>&emsp;&emsp;GFS是一个用于支持分布式应用程序的文件系统，在分布式文件系统中，我们需要考虑以下问题：首先，组件的失败是不可避免的，比如磁盘损坏，网络不稳定及应用程序Bug等，所以一个分布式的文件系统必须具备持续监控、错误检测、错误容忍和自动恢复的能力；其次，文件系统中的文件通常非常巨大，动辄几百GB，当然也有大量的小文件，所以分布式的文件系统中的IO操作和数据块大小必须精心设计；最后，大多数对分布式文件系统中的写操作通常是追加写，而不会对文件系统中已经存在的数据进行覆盖，所以提高系统的追加写性能和其原子性是非常重要的。GFS就是大致基于这些设计假设来设计的分布式文件系统。</p>
<h2 id="GFS设计假设"><a href="#GFS设计假设" class="headerlink" title="GFS设计假设"></a>GFS设计假设</h2><ol>
<li>文件系统由一些廉价的商用组件组成，它们有一定的失败（损坏）概率，所以他们需要自我检测并在失败时迅速自我恢复。</li>
<li>文件系统中的文件通常为大文件（100MB或更大），小文件也被支持，但不会被优化</li>
<li>文件系统的读工作负载通常由两种读操作组成：大规模的流式读取和小规模的随机读取。小规模随机读取通常由偏移量来控制，同时大量的小规模读取在文件系统中被重排，以减少文件读取过程中回溯。</li>
<li>文件系统的写工作负载通常为追加，很少去修改已经写入的数据，文件一经写入很少会被修改。系统支持随机少量数据的写入但不会对其做优化。</li>
<li>文件系统在并发写文件下要有高效的语义实现，要确保原子性和最小的同步开销。因为该系统经常会被当作生产者消费者队列来使用，或用于多路归并。</li>
<li>高带宽比低延迟更重要。</li>
</ol>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>GFS主要提供以下接口：create、delete、open、close、read、write、snapshot和record append。</p>
<h2 id="系统构建"><a href="#系统构建" class="headerlink" title="系统构建"></a>系统构建</h2><p>&emsp;&emsp;GFS主要由以下几部分构成：单个master（主节点），多个chunkserver（块服务器）和多个client（客户机）。在GFS中文件被分为合适大小的区块，每个区块有一个chunk handle（区块句柄）唯一标定，这个句柄在区块建立时由master分配。默认每个区块在系统中存在三个备份。master保管所有文件的metadata（元数据），其中包括文件的命名空间、访问权限和文件到区块的映射，master会周期的通过HeartBeat消息同chunkserver通信，发布自己的命令并收集每个chunkserver的状态。client和chunkserver都不提供缓存功能。</p>
<p>GFS系统构件如下图所示：</p>
<p><img src="/img/blog/GFS/GFS1.jpg" alt="GFS构建图"></p>
<h3 id="单个master"><a href="#单个master" class="headerlink" title="单个master"></a>单个master</h3><p>&emsp;&emsp;单个master可以简化系统的设计，并且确保master通过全局的知识可以精确的控制区块的部署，但是为了不让单个的master变为系统的瓶颈，client的读写操作不会和master产生任何联系，它只会询问master应该请求那个chunkserver，同时缓存这个信息（减少和master的交流次数），一个简单的读操作流程如下：</p>
<ol>
<li>使用固定的块大小，client将应用程序指定的文件名和字节偏移量翻译成文件内的块索引。</li>
<li>client向主节点发送包含文件名和块索引的请求。</li>
<li>主节点回复对应的块句柄和每个备份所在的位置。同时客户端使用文件名和块索引作为键缓存该信息。</li>
<li>client访问最近的备份所在的chunkserver，通过块句柄和块的字节范围</li>
</ol>
<p>再次请求相同的文件内容时，client只需要从缓存中读出信息即可，无需再次请求master，除非缓存消失或者chunkserver损坏。</p>
<h3 id="区块大小"><a href="#区块大小" class="headerlink" title="区块大小"></a>区块大小</h3><p>&emsp;&emsp;GFS采用64MB作为块大小，远大于传统文件系统。每个块副本以Linux文件形式存储，使用延迟空间分配策略来避免空间浪费。这种大块设计具有三个主要优势：减少了客户端与主服务器的交互需求，因为同一数据块操作只需请求一次位置信息；客户端可与数据服务器保持持久TCP连接，降低网络开销；减少主服务器的元数据存储量，使其能完全保存在内存中。不过，大块设计也面临挑战：小文件通常只有一个数据块，多客户端同时访问时可能造成服务器热点问题。为此，系统采取了增加热点文件副本数量、错开应用启动时间等解决方案，并考虑实现客户端间直接数据传输。</p>
<h3 id="metadata（元数据）"><a href="#metadata（元数据）" class="headerlink" title="metadata（元数据）"></a>metadata（元数据）</h3><p>&emsp;&emsp;GFS（Google文件系统）中的元数据由主服务器存储，主要包括文件和块的命名空间、文件与块的映射关系以及每个块副本的位置。所有元数据保存在主服务器的内存中，命名空间和文件到块的映射通过操作日志进行持久化，以确保在主服务器崩溃时不会出现不一致。主服务器在启动时向每个chunkserver请求块位置的信息，而不持久保存这些信息。</p>
<p>&emsp;&emsp;由于元数据存储在内存中，主服务器的操作速度非常快，并且可以定期扫描状态以实现块垃圾回收、重新复制和负载均衡等功能。虽然内存限制了系统的块数量，但实际使用中，这并不是一个严重的问题，因为每个64MB的块仅需64字节的元数据，大多数文件包含多个完整的块，只有最后一个块是不完整的。</p>
<p>&emsp;&emsp;操作日志是GFS的核心，记录了关键的元数据变化，并定义了并发操作的顺序。为了保证日志的可靠性，GFS在多个远程机器上复制操作日志，并在将更改对客户端可见之前，确保日志记录已持久化。主服务器通过重放操作日志来恢复文件系统状态，并在日志增大时创建检查点以加快恢复过程。检查点以紧凑的B树形式存储，可以直接映射到内存中，从而提高查找速度和可用性。检查点创建过程不会影响系统性能，确保了系统的高效性和可靠性。</p>
<h2 id="一致性模型"><a href="#一致性模型" class="headerlink" title="一致性模型"></a>一致性模型</h2><p>&emsp;&emsp;GFS（Google文件系统）采用了一种宽松的一致性模型，既支持高度分布式的应用，又保持了实现的简单高效。</p>
<h3 id="GFS的一致性保证"><a href="#GFS的一致性保证" class="headerlink" title="GFS的一致性保证"></a>GFS的一致性保证</h3><ol>
<li>文件命名空间的变更操作是原子的，由主服务器独家处理。文件区域在数据变更后的状态取决于变更类型、是否成功以及是否有并发变更。成功且无并发写入的变更会使区域变为已定义状态；并发的成功变更会导致区域处于未定义但一致的状态；失败的变更则使区域变得不一致。</li>
<li>数据变更包括写入和记录追加两种操作。GFS保证在一系列成功的变更后，变更的文件区域将处于已定义状态，并包含最后一次变更写入的数据。这是通过在所有副本上按相同顺序应用变更，并使用块版本号检测过时副本来实现的。</li>
<li>GFS通过定期与数据服务器进行握手来识别故障，并通过校验和检测数据损坏。一旦发现问题，系统会尽快从有效副本恢复数据。只有在GFS反应之前所有副本都丢失的极端情况下，数据才会不可逆转地丢失，但即便如此，应用程序也会收到明确的错误提示，而不是损坏的数据。</li>
</ol>
<h3 id="应用程序的隐含语义"><a href="#应用程序的隐含语义" class="headerlink" title="应用程序的隐含语义"></a>应用程序的隐含语义</h3><p>&emsp;&emsp;GFS的应用程序通过几种简单技术来适应其宽松的一致性模型：依赖追加而非覆写、使用检查点机制以及写入自验证和自识别的记录。在典型应用场景中，写入程序从头到尾生成文件，完成后通过原子重命名操作确定文件名，或定期设置检查点标记写入进度。读取程序只处理到最后一个检查点的文件内容，确保数据处于已定义状态。这种追加方式比随机写入更高效，也更能抵御应用程序故障。对于多写入者并发追加的场景，系统通过”至少追加一次”的语义来保护每个写入者的输出。写入的记录包含校验和等额外信息以验证有效性，读取程序可以通过校验和识别并丢弃多余的填充和记录片段，必要时还可以使用记录中的唯一标识符过滤重复内容。</p>
<h1 id="GFS系统构件间的交互"><a href="#GFS系统构件间的交互" class="headerlink" title="GFS系统构件间的交互"></a>GFS系统构件间的交互</h1><p>这个章节将具体介绍GFS中master、client和chunkserver如何交互以实现我们前面提到的数据修改，原子的记录追加和快照。</p>
<h2 id="数据修改"><a href="#数据修改" class="headerlink" title="数据修改"></a>数据修改</h2><p>&emsp;&emsp;在GFS中，数据修改（mutation）是指改变块内容或元数据的操作，如写入或追加。为了在副本之间保持一致的变更顺序，GFS使用租约（lease）机制。主服务器将块租约授予一个副本，称为主副本（primary），该副本为所有变更指定一个串行顺序，所有副本按照这个顺序应用变更。租约的初始超时时间为60秒，但只要块正在被变更，主副本可以请求并通常会获得无限期的延长。</p>
<p>数据修改流程图如下：<br><img src="/img/blog/GFS/GFS2.jpg" alt="GFS数据修改流程"></p>
<p>以下是写入过程的控制流程：</p>
<ol>
<li>客户端向master询问当前持有块租约的chunkserver及其他副本的位置。如果没有租约，主服务器将其授予一个副本。</li>
<li>主服务器回复主副本的身份和其他（次级）副本的位置。客户端缓存这些数据，以便未来的变更，只需在主副本不可达或不再持有租约时再次联系master。</li>
<li>客户端将数据推送到所有副本，可以按任意顺序进行。每个chunkserver器会在内部LRU缓冲区缓存数据，直到数据被使用或过期。</li>
<li>一旦所有副本确认接收到数据，客户端向主副本发送写请求，请求中标识了之前推送的数据。主副本为接收到的所有变更分配连续的序列号，以提供必要的序列化，并按序列号顺序将变更应用于其本地存储的数据。</li>
<li>主副本将写请求转发给所有次级副本。每个次级副本按照主副本分配的序列号顺序应用变更。</li>
<li>所有次级副本回复主副本，表示已完成操作。</li>
<li>主副本向客户端回复。如果任何副本遇到错误，将报告给客户端。如果在主副本成功但某些次级副本失败，则请求被视为失败，修改区域处于不一致状态。客户端代码会通过重试失败的变更（3～7步）来处理这些错误。</li>
</ol>
<p>&emsp;&emsp;如果应用程序的写入较大或跨越块边界，GFS客户端代码会将其拆分为多个写操作，这些操作遵循上述控制流程，但可能与其他客户端的并发操作交错。因此，共享文件区域可能包含来自不同客户端的片段，但由于各个操作在所有副本上成功完成且顺序相同，最终结果仍然保持一致但未定义状态。</p>
<h2 id="数据流传输"><a href="#数据流传输" class="headerlink" title="数据流传输"></a>数据流传输</h2><p>&emsp;&emsp;GFS将数据流与控制流分离，以实现网络的高效利用。控制流从客户端流向主副本，再到所有次级副本；而数据则通过精心选择的chunkserver链进行流水线式传输。系统采用线性链式传输而非树形等其他拓扑结构，确保每台机器的网络带宽得到充分利用。每台机器将数据转发给网络拓扑中最”近”的、尚未接收数据的机器，从而避免网络瓶颈和高延迟链路。系统通过IP地址可以准确估算机器间的”距离”（这得益于Google的网络拓扑结构）。为了最小化延迟，数据通过TCP连接进行流水线传输。块服务器一旦接收到数据就立即开始转发，这种方式在全双工链路的交换网络中特别有效。</p>
<h2 id="原子的记录追加"><a href="#原子的记录追加" class="headerlink" title="原子的记录追加"></a>原子的记录追加</h2><p>&emsp;&emsp;GFS提供了一种称为记录追加（record append）的原子追加操作。在传统写入中，客户端需要指定数据写入的偏移量，导致并发写入可能产生数据片段混合的问题。而在记录追加中，客户端只需指定要追加的数据，GFS会将其原子性地追加到文件中，偏移量由GFS自行选择，并将该偏移量返回给客户端。这种方式类似于Unix中以O_APPEND模式打开文件的写入，避免了多写入者并发时的竞争条件。</p>
<h2 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h2><p>&emsp;&emsp;GFS的快照（snapshot）操作能够几乎瞬间复制文件或目录树，同时最小化对正在进行的变更的干扰。用户可以利用快照快速创建大型数据集的分支副本，或在进行实验性更改前保存当前状态。快照实现采用写时复制技术。当master收到快照请求时，首先撤销待快照文件中所有块的未过期租约，确保后续写入需要与master交互（必须重新请求master租约的持有者）。master将操作记录到磁盘后，通过复制源文件或目录树的元数据来更新内存状态。新创建的快照文件指向与源文件相同的数据块。当快照操作后客户端首次要写入某个块时，master会注意到该块的引用计数大于1。此时，master会选择一个新的块标识符，并要求拥有当前副本的块服务器创建新块。通过在相同的块服务器上创建新块，确保数据可以在本地复制，避免网络传输，提高效率。之后的请求处理与普通块处理相同。</p>
<h1 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h1><p>&emsp;&emsp;master在GFS中负责执行所有命名空间操作，同时管理整个系统中的块副本。其核心职责包括决定块的放置位置、创建新的块和副本、协调系统范围的活动，以确保块的完整复制、在块服务器之间实现负载均衡，以及回收未使用的存储空间。</p>
<h2 id="基于读写锁的命名空间管理"><a href="#基于读写锁的命名空间管理" class="headerlink" title="基于读写锁的命名空间管理"></a>基于读写锁的命名空间管理</h2><p>&emsp;&emsp;GFS主服务器的操作可能耗时较长，为了避免延迟其他操作，系统采用锁机制来确保命名空间区域的正确序列化。与传统文件系统不同，GFS不维护目录数据结构，也不支持文件别名，而是将命名空间表示为一个将完整路径名映射到元数据的查找表。GFS的锁机制基于命名空间树中的节点，每个节点都有一个读写锁。操作执行时，会获取相关路径上的一系列锁。例如，对于路径&#x2F;d1&#x2F;d2&#x2F;…&#x2F;dn&#x2F;leaf的操作，会获取各级目录的读锁（&#x2F;d1, &#x2F;d1&#x2F;d2, … , &#x2F;d1&#x2F;d2…&#x2F;dn的读锁），以及最终路径（&#x2F;d1&#x2F;d2&#x2F;…&#x2F;dn&#x2F;leaf）的读锁或写锁。这种设计允许同一目录下的并发修改操作，比如多个文件可以同时在同一目录下创建。为了防止死锁，锁的获取遵循一致的顺序规则：首先按命名空间树的层级排序，同一层级内按字典序排序。考虑到命名空间可能包含大量节点，读写锁对象采用懒加载方式分配，不使用时即被删除。</p>
<h2 id="副本部署"><a href="#副本部署" class="headerlink" title="副本部署"></a>副本部署</h2><p>&emsp;&emsp;GFS集群在多个层面上实现高度分布式：数百个chunkserver分布在多个子网上，同时被来自相同或不同子网的数百个客户端访问。不同子网间的机器通信可能需要经过多个网络交换机，且子网的带宽可能小于其内部所有机器的总带宽。块副本的部署策略主要取决于两个目标：最大化数据的可靠性和可用性，以及最大化网络带宽利用率。系统不仅要将副本分布在不同机器上以防止磁盘或机器故障，更要将块副本分布在不同子网上。这样即使某个子网出现故障（如网络交换机或电路故障），部分副本仍能存活并保持可用。这种策略也使得数据访问可以利用多个子网的总带宽，尽管写入流量需要经过多个子网，但为了数据的可用性这是必须作出的权衡。</p>
<h2 id="区块（副本）的创建、重部署和再平衡"><a href="#区块（副本）的创建、重部署和再平衡" class="headerlink" title="区块（副本）的创建、重部署和再平衡"></a>区块（副本）的创建、重部署和再平衡</h2><h3 id="区块创建"><a href="#区块创建" class="headerlink" title="区块创建"></a>区块创建</h3><p>&emsp;&emsp;Master在创建新块时会综合考虑多个因素来决定副本的放置位置。首先，系统会选择磁盘利用率低于平均水平的chunkserver，这样可以随时间推移实现各服务器间的磁盘使用均衡。其次，会限制每个服务器上最近创建的块数量，因为新创建的块往往预示着即将到来的大量写入操作。最后，系统会确保将副本分布在不同子网上，以提高数据可靠性和可用性。</p>
<h3 id="区块重部署"><a href="#区块重部署" class="headerlink" title="区块重部署"></a>区块重部署</h3><p>&emsp;&emsp;当某个块的可用副本数量低于用户指定的目标值时，系统会触发重新复制机制。这种情况可能由多种原因导致，比如chunkserver不可用、副本损坏或磁盘故障等。系统会根据以下因素为需要复制的块分配优先级：</p>
<ol>
<li>与目标副本数的差距（失去两个副本比失去一个副本的优先级更高）</li>
<li>文件的活跃状态（活跃文件优先于已删除文件）</li>
<li>是否影响客户端操作（阻塞客户端进度的块会获得更高优先级）</li>
</ol>
<h3 id="区块再平衡"><a href="#区块再平衡" class="headerlink" title="区块再平衡"></a>区块再平衡</h3><p>&emsp;&emsp;Master会定期检查系统中副本的分布情况，并通过移动副本来优化磁盘空间使用和负载均衡。在处理新加入的chunkserver时，系统采用渐进式填充策略，避免突然分配大量数据而导致过重的写入负载。为了防止复制操作影响正常客户端访问，系统会对整个集群和单个chunkserver的同时复制操作数量进行限制，并通过限制带宽来控制复制速度。</p>
<p>这种多层次的副本管理机制确保了GFS能够在保持高可用性的同时，实现良好的负载均衡和资源利用率</p>
<h1 id="GFS的垃圾回收机制"><a href="#GFS的垃圾回收机制" class="headerlink" title="GFS的垃圾回收机制"></a>GFS的垃圾回收机制</h1><h2 id="回收机制"><a href="#回收机制" class="headerlink" title="回收机制"></a>回收机制</h2><p>&emsp;&emsp;当用户（client）删除一个文件时，GFS中的垃圾回收机制会被触发。当文件被删除后，系统不会立即回收其占用的物理存储空间，而是采用延迟处理的方式，这种懒惰回收的策略使得系统设计更加简单，同时也提高了系统的可靠性。这种方法虽然不会立即释放存储空间，但通过简化系统操作，降低了系统的复杂度，从而提高了整体的稳定性。</p>
<p>&emsp;&emsp;当应用程序删除文件时，master不会立即回收资源，而是将文件重命名为包含删除时间戳的隐藏文件。这些文件在三天内（可配置）仍然可以被读取和恢复。超过期限后，master会在例行扫描时删除这些隐藏文件的元数据，切断它们与数据块的联系（删除它的metadata）。</p>
<p>&emsp;&emsp;在master定期扫描数据块命名空间时，会识别出孤立的数据块（即无法从任何文件访问的块），并删除这些块的元数据。各个chunkserver在与master进行HeartBeat通信时，会报告它们持有的数据块信息，master则会告知哪些数据块在元数据中已不存在，chunkserver随后可以删除这些块的副本。</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>&emsp;&emsp;这种垃圾回收方式比直接删除有几个优势：首先，它在大规模分布式系统中更可靠；其次，它将存储回收与master的常规后台活动合并，成本分摊且不影响主要业务；最后，延迟删除可以防止意外删除（Rename文件就可以恢复它）。主要缺点是在存储空间紧张时可能会影响用户对存储空间的精细控制，对此系统提供了一些解决方案，比如允许用户为不同的命名空间设置不同的复制和回收策略。</p>
<h2 id="旧副本（无效副本）检测"><a href="#旧副本（无效副本）检测" class="headerlink" title="旧副本（无效副本）检测"></a>旧副本（无效副本）检测</h2><p>&emsp;&emsp;Master为每个数据块维护一个版本号，用于区分最新和过期的副本。当master授予数据块新的租约时，会增加版本号并通知所有最新的副本。master和这些chunkserver都会在持久存储中记录新的版本号，这个过程发生在通知客户端之前。</p>
<p>&emsp;&emsp;如果某个chunkserver在宕机期间错过了数据块的修改，其副本就会变得过期。当这个服务器重启并报告其数据块信息时，master会通过比对版本号发现过期的副本。如果master发现某个版本号比自己记录的更高，它会认为这是由于自己在授予租约时发生了故障，并采用较高的版本号作为最新版本。</p>
<p>master会在常规垃圾回收中移除过期副本。在此之前，当回应客户端请求数据块信息时，它会完全忽略过期副本的存在。作为额外的安全措施，master在告知客户端哪个chunkserver持有租约，或指示chunkserver从其他服务器克隆数据时，都会包含版本号信息。客户端或chunkserver在执行操作时会验证版本号，确保始终访问最新的数据。</p>
<h1 id="错误容忍与诊断"><a href="#错误容忍与诊断" class="headerlink" title="错误容忍与诊断"></a>错误容忍与诊断</h1><p>&emsp;&emsp;在分布式系统中，处理频繁的组件故障是最大的挑战之一。由于系统规模庞大且使用大量普通硬件设备，组件故障已经成为一种常态而非异常情况。系统既不能完全信任机器，也不能完全信任磁盘的可靠性。这些组件故障可能导致系统不可用，更严重的是可能造成数据损坏。因此，GFS必须建立相应的故障诊断工具和机制来应对这些不可避免的问题。</p>
<h2 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h2><p>&emsp;&emsp;高可用性主要由两个简单且高效的机制保证：快速恢复和复制（冗余）。</p>
<h3 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h3><p>&emsp;&emsp;master和chunkserver都被设计为能在几秒钟内恢复状态并重新启动，无论是何种原因导致的终止。系统对正常终止和异常终止的处理方式是一样的，服务器甚至可以通过直接终止进程的方式来进行例行关闭。当服务器重启时，客户端和其他服务器只会经历短暂的中断：它们会在当前请求超时后，重新连接到重启的服务器并重试之前的操作。</p>
<h3 id="块复制"><a href="#块复制" class="headerlink" title="块复制"></a>块复制</h3><p>&emsp;&emsp;每个数据块都会在不同机架的多个chunkserver上进行复制。用户可以为文件系统命名空间的不同部分指定不同的复制级别，默认是三个副本。当chunkserver离线或通过校验和验证检测到损坏的副本时，master会克隆现有副本以保持每个数据块的完整复制。</p>
<p>&emsp;&emsp;虽然复制机制运行良好，但系统也在探索其他形式的跨服务器冗余方案，如奇偶校验或纠删码，以满足不断增长的只读存储需求。由于系统的流量主要是追加写入和读取操作，而不是小型随机写入，因此在这种松耦合系统中实现这些更复杂的冗余方案虽然具有挑战性，但仍是可控的。</p>
<h3 id="Master复制"><a href="#Master复制" class="headerlink" title="Master复制"></a>Master复制</h3><p>&emsp;&emsp;为了保证可靠性，master的状态会在多台机器上进行复制，包括操作日志和检查点。只有当日志记录在本地磁盘和所有master副本上都完成刷新后，对状态的修改才被视为已提交。为了简单起见，一个master进程负责所有的修改操作和后台活动。如果master发生故障，它可以几乎立即重启；如果其机器或磁盘出现故障，GFS外部的监控基础设施会在其他地方启动新的master进程。</p>
<p>&emsp;&emsp;系统还设置了”影子”master，提供文件系统的只读访问服务。这些影子master与主master可能会有轻微的时间差，通常是几分之一秒。它们主要用于提高那些不经常修改的文件或对略微过期的结果可以容忍的应用程序的读取可用性。由于文件内容是从chunkserver读取的，应用程序不会看到过期的文件内容，可能过期的只是文件元数据，如目录内容或访问控制信息。影子master通过读取操作日志副本并按照与主master相同的顺序应用更改来保持信息更新。它们在启动时会轮询chunkserver以定位数据块副本，并通过定期的握手消息监控其状态。影子master只在副本位置更新方面依赖主master，这些更新是由主master创建和删除副本的决策产生的。</p>
<h2 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h2><p>&emsp;&emsp;GFS主要通过校验和来保障块及其副本的数据完整性。</p>
<p>&emsp;&emsp;每个chunkserver使用校验和技术来检测存储数据的损坏。由于GFS集群通常拥有数千个磁盘和数百台机器，定期会发生磁盘故障，导致读取和写入路径上的数据损坏或丢失。虽然可以通过其他副本恢复数据，但通过比较不同chunkserver之间的副本来检测损坏是不切实际的。此外，因GFS的修改语义（尤其是原子记录追加）可能导致不同的副本是合法的，因此每个chunkserver必须独立验证其副本的完整性，方法是维护校验和。</p>
<p>&emsp;&emsp;每个chunk被分为64 KB的块，每个块都有一个对应的32位校验和。校验和与其他元数据一样，保存在内存中并与日志一起持久存储。对于读取操作，chunkserver在返回数据之前会验证重叠读取范围内的数据块的校验和，从而避免将损坏的数据传播到其他机器。如果块与记录的校验和不匹配，chunkserver会向请求者返回错误并将不匹配情况报告给master。请求者会从其他副本读取，而master则会从另一个副本克隆该chunk。在有效的新副本就位后，master会指示报告不匹配的chunkserver删除其副本。</p>
<p>&emsp;&emsp;校验和对读取性能影响较小，因为大多数读取操作跨越多个块，只需读取相对较少的额外数据进行验证。此外，chunkserver上的校验和查找和比较不涉及任何I&#x2F;O操作，且校验和计算通常可以与I&#x2F;O操作重叠。对于追加写入操作，校验和计算经过优化，只需增量更新最后一个部分块的校验和，并为新填充的任何完整块计算新的校验和。如果最后一个部分块已损坏且未被及时检测到，新的校验和值在下次读取时仍会发现不匹配。</p>
<p>&emsp;&emsp;相反，对于覆盖写入操作，需要在写入之前读取并验证被覆盖范围的首尾块，然后执行写入并计算记录新的校验和。在未验证首尾块之前进行部分覆盖写入可能会隐藏未被覆盖区域的损坏。在空闲期间，chunkserver可以扫描并验证不活跃chunks的内容，以检测不常读取chunks中的损坏。一旦发现损坏，master可以创建新的未损坏副本并删除损坏副本，从而防止不活跃但已损坏的副本误导master认为有足够有效的副本存在。</p>
<h2 id="诊断工具"><a href="#诊断工具" class="headerlink" title="诊断工具"></a>诊断工具</h2><p>&emsp;&emsp;GFS系统通过详细的诊断日志记录显著提升了问题隔离、调试和性能分析的能力，同时只带来了极小的成本。没有日志，很难理解机器之间瞬时且不可重复的交互。GFS服务器生成的诊断日志记录了许多重要事件（如chunkserver的上下线）以及所有RPC请求和响应。这些诊断日志可以在不影响系统正确性的情况下自由删除，但应当尽量在空间允许的情况下保留这些日志。</p>
<p>&emsp;&emsp;RPC日志包括在网络上发送的确切请求和响应，除了正在读取或写入的文件数据。通过将请求与响应匹配并整理不同机器上的RPC记录，我们可以重建整个交互历史以诊断问题。这些日志也可作为负载测试和性能分析的追踪记录。由于这些日志是顺序和异步写入的，因此其对性能的影响很小，且远远被其带来的好处所抵消。最新事件也会保存在内存中，以便进行持续的在线监控。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;GFS展示了在商品硬件上支持大规模数据处理工作负载所需的关键特性。尽管某些设计决策是针对Google独特环境的，但许多原则也适用于类似规模和成本意识的数据处理任务。GFS通过重新审视传统文件系统的假设，以适应当前和预期的应用工作负载及技术环境，做出了根本性的设计改变。</p>
<p>&emsp;&emsp;GFS将组件故障视为常态，优化了主要以追加方式写入的大文件，并在读取时通常采用顺序方式。系统通过持续监控、复制关键数据以及快速自动恢复来提供容错能力，数据块复制使其能够容忍chunkserver的故障。此外，GFS开发了一种在线修复机制，能够定期且透明地修复损坏并尽快补偿丢失的副本。校验和技术则用于检测磁盘或IDE子系统级别的数据损坏，这在系统中存在大量磁盘的情况下变得尤为重要。</p>
<p>&emsp;&emsp;通过将文件系统控制与数据传输分离，GFS为多个并发读写者提供了高总吞吐量。较大的块大小和chunk租约的设计减少了master在常见操作中的参与，使得简单的集中式master不会成为瓶颈。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://peacill.online">pEacill</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://peacill.online/post/22157.html">https://peacill.online/post/22157.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://peacill.online" target="_blank">pEacill</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Distributed/">Distributed</a><a class="post-meta__tags" href="/tags/File-System/">File System</a></div><div class="post-share"><div class="social-share" data-image="/img/blog/GFS/gfs_cover.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/post/42123.html" title="VMware FT: Practical System for Fault-Tolerant Virtual Machines"><img class="cover" src="/img/blog/VMwareFT/VMFT_cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">VMware FT: Practical System for Fault-Tolerant Virtual Machines</div></div><div class="info-2"><div class="info-item-1">本文将介绍2010年由VMware公司提出的商业级的容错虚拟机系统，该系统基于VMware vSphere 4.0设计。该系统通过在另一台服务器上复制主虚拟机的执行来提供容错支持，同时可以在故障发生后自动恢复冗余。 论文参考：《The Design of a Practical System for Fault-Tolerant Virtual...</div></div></div></a><a class="pagination-related" href="/post/50511.html" title="Golang编程技巧——TDD"><img class="cover" src="/img/blog/TDD/TDD_cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Golang编程技巧——TDD</div></div><div class="info-2"><div class="info-item-1">本文将介绍一种应用于Go语言中的编程技巧TDD（Test Driven Development测试驱动开发），这一技巧主要得益于Go语言强大的testing包。 参考书目：《Go Design...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/post/64376.html" title="MapReduce浅析"><img class="cover" src="/img/blog/MapReduce/MapReduce_cover.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-17</div><div class="info-item-2">MapReduce浅析</div></div><div class="info-2"><div class="info-item-1"> 本文将详细介绍由Google提出的一种用于大规模数据集并行处理的编程模型和计算框架——MapReduce，该框架目前已经很少被用在生产环境中，但其背后的基本思想仍然在现代大数据处理技术中占有重要地位 论文参考：《MapReduce: Simplified Data Processing on Large...</div></div></div></a><a class="pagination-related" href="/post/42123.html" title="VMware FT: Practical System for Fault-Tolerant Virtual Machines"><img class="cover" src="/img/blog/VMwareFT/VMFT_cover.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-23</div><div class="info-item-2">VMware FT: Practical System for Fault-Tolerant Virtual Machines</div></div><div class="info-2"><div class="info-item-1">本文将介绍2010年由VMware公司提出的商业级的容错虚拟机系统，该系统基于VMware vSphere 4.0设计。该系统通过在另一台服务器上复制主虚拟机的执行来提供容错支持，同时可以在故障发生后自动恢复冗余。 论文参考：《The Design of a Practical System for Fault-Tolerant Virtual...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">pEacill</div><div class="author-info-description">Keep Striving!</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/pEacill"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/pEacill" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:jia_liii@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">本网站中所有封面图片均来自于Instagram@linksphotograph的摄影作品</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#GFS%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.</span> <span class="toc-text">GFS设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GFS%E8%AE%BE%E8%AE%A1%E5%81%87%E8%AE%BE"><span class="toc-number">1.1.</span> <span class="toc-text">GFS设计假设</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA"><span class="toc-number">1.3.</span> <span class="toc-text">系统构建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%B8%AAmaster"><span class="toc-number">1.3.1.</span> <span class="toc-text">单个master</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.3.2.</span> <span class="toc-text">区块大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#metadata%EF%BC%88%E5%85%83%E6%95%B0%E6%8D%AE%EF%BC%89"><span class="toc-number">1.3.3.</span> <span class="toc-text">metadata（元数据）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.4.</span> <span class="toc-text">一致性模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GFS%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E4%BF%9D%E8%AF%81"><span class="toc-number">1.4.1.</span> <span class="toc-text">GFS的一致性保证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%9A%90%E5%90%AB%E8%AF%AD%E4%B9%89"><span class="toc-number">1.4.2.</span> <span class="toc-text">应用程序的隐含语义</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GFS%E7%B3%BB%E7%BB%9F%E6%9E%84%E4%BB%B6%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92"><span class="toc-number">2.</span> <span class="toc-text">GFS系统构件间的交互</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BF%AE%E6%94%B9"><span class="toc-number">2.1.</span> <span class="toc-text">数据修改</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E4%BC%A0%E8%BE%93"><span class="toc-number">2.2.</span> <span class="toc-text">数据流传输</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E7%9A%84%E8%AE%B0%E5%BD%95%E8%BF%BD%E5%8A%A0"><span class="toc-number">2.3.</span> <span class="toc-text">原子的记录追加</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E7%85%A7"><span class="toc-number">2.4.</span> <span class="toc-text">快照</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Master"><span class="toc-number">3.</span> <span class="toc-text">Master</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="toc-number">3.1.</span> <span class="toc-text">基于读写锁的命名空间管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%AF%E6%9C%AC%E9%83%A8%E7%BD%B2"><span class="toc-number">3.2.</span> <span class="toc-text">副本部署</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%EF%BC%88%E5%89%AF%E6%9C%AC%EF%BC%89%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E9%87%8D%E9%83%A8%E7%BD%B2%E5%92%8C%E5%86%8D%E5%B9%B3%E8%A1%A1"><span class="toc-number">3.3.</span> <span class="toc-text">区块（副本）的创建、重部署和再平衡</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E5%88%9B%E5%BB%BA"><span class="toc-number">3.3.1.</span> <span class="toc-text">区块创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%87%8D%E9%83%A8%E7%BD%B2"><span class="toc-number">3.3.2.</span> <span class="toc-text">区块重部署</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E5%86%8D%E5%B9%B3%E8%A1%A1"><span class="toc-number">3.3.3.</span> <span class="toc-text">区块再平衡</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GFS%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">4.</span> <span class="toc-text">GFS的垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">4.1.</span> <span class="toc-text">回收机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">4.2.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A7%E5%89%AF%E6%9C%AC%EF%BC%88%E6%97%A0%E6%95%88%E5%89%AF%E6%9C%AC%EF%BC%89%E6%A3%80%E6%B5%8B"><span class="toc-number">4.3.</span> <span class="toc-text">旧副本（无效副本）检测</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%AE%B9%E5%BF%8D%E4%B8%8E%E8%AF%8A%E6%96%AD"><span class="toc-number">5.</span> <span class="toc-text">错误容忍与诊断</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7"><span class="toc-number">5.1.</span> <span class="toc-text">高可用性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D"><span class="toc-number">5.1.1.</span> <span class="toc-text">快速恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%97%E5%A4%8D%E5%88%B6"><span class="toc-number">5.1.2.</span> <span class="toc-text">块复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Master%E5%A4%8D%E5%88%B6"><span class="toc-number">5.1.3.</span> <span class="toc-text">Master复制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-number">5.2.</span> <span class="toc-text">数据完整性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7"><span class="toc-number">5.3.</span> <span class="toc-text">诊断工具</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/20527.html" title="C++ concurrent data structures based on lock"><img src="/img/blog/dslock/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++ concurrent data structures based on lock"/></a><div class="content"><a class="title" href="/post/20527.html" title="C++ concurrent data structures based on lock">C++ concurrent data structures based on lock</a><time datetime="2025-01-02T10:24:26.000Z" title="发表于 2025-01-02 18:24:26">2025-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/9989.html" title="Raft: A Understandable Consensus Algorithm"><img src="/img/blog/Raft/Raft_cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Raft: A Understandable Consensus Algorithm"/></a><div class="content"><a class="title" href="/post/9989.html" title="Raft: A Understandable Consensus Algorithm">Raft: A Understandable Consensus Algorithm</a><time datetime="2024-12-25T07:22:00.000Z" title="发表于 2024-12-25 15:22:00">2024-12-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/42123.html" title="VMware FT: Practical System for Fault-Tolerant Virtual Machines"><img src="/img/blog/VMwareFT/VMFT_cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="VMware FT: Practical System for Fault-Tolerant Virtual Machines"/></a><div class="content"><a class="title" href="/post/42123.html" title="VMware FT: Practical System for Fault-Tolerant Virtual Machines">VMware FT: Practical System for Fault-Tolerant Virtual Machines</a><time datetime="2024-12-23T13:33:22.000Z" title="发表于 2024-12-23 21:33:22">2024-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/22157.html" title="GFS: The Google file system"><img src="/img/blog/GFS/gfs_cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GFS: The Google file system"/></a><div class="content"><a class="title" href="/post/22157.html" title="GFS: The Google file system">GFS: The Google file system</a><time datetime="2024-12-22T05:20:45.000Z" title="发表于 2024-12-22 13:20:45">2024-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/50511.html" title="Golang编程技巧——TDD"><img src="/img/blog/TDD/TDD_cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang编程技巧——TDD"/></a><div class="content"><a class="title" href="/post/50511.html" title="Golang编程技巧——TDD">Golang编程技巧——TDD</a><time datetime="2024-12-21T08:14:32.000Z" title="发表于 2024-12-21 16:14:32">2024-12-21</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/footer.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By pEacill</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23liIJFpxYJSsumkSe',
      clientSecret: 'd098208f5550f91f3f7da5b6e60850bc56d798d4',
      repo: 'LLjrr.github.io',
      owner: 'LLjrr',
      admin: ['LLjrr'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || 'cd24cee734c0efa177e6e51de5c33676'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>